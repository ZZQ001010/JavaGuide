# 1.final

- 作用于类上,此类不可以被继承, **final类的所有方法都会隐式的指定为final方法**
- final 作用于变量上,
  - 如果变量为基本类型变量,数值在初始化之后不能够改变
  - 如果为引用类型变量,对其进行初始化之后不能够再让其指定其他对象

- final作用方法有两个原因
  - 把方法锁定,以防任何继承类修改她的含义
  - java早期效率问题,在早期,会把final转换为内嵌调用,**类中所有的private方法都隐式地指定为final**

# 2.static

- 修饰成员变量,成员方法

  - 被 static 修饰的成员**属于类**,**不属于单个这个类的某个对象(实例)**,静态变量 存放在 Java **内存区域的方法区**(方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

    HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。)

- **静态代码块 **
  - 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，**静态代码块只执行一次**
  - 对于在静态代码块之后的静态变量**可以赋值**,**但是不能访问**

- **静态内部类（static修饰类的话只能修饰内部类）：**
  - 静态内部类和内部类的区别就是,内部类编译完成之后,会隐含地保存一个引用,引用指向外围类,但是静态内部类没有,
  - 静态内部类的创建不需要外围类的创建
  - 他不能使用外围类非static 的静态变量

- 静态导包(用于导入类中的静态资源,1.5新特性),通过import static直接指定某类中的静态资源

# 3.this

this表示当前实例,本对象

# 4.super 

从子类访问

**使用 this 和 super 要注意的问题：**

- super 调用父类中的其他构造方法时，调用时要放在构造方法的首行！this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。

**this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

# 5.补充说明

静态方法本身属于类本身,实例方法属于该类生成的每个对象,如果执行方法不依赖每个类的变量,方法,将其设置为静态,(**减小程序占用空间)**

## static{}静态代码块与{}非静态代码块（构造代码块）

 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。

## 非静态代码块与构造函数的区别是

 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容



























































